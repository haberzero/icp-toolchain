# MCCP-toolchain

仓库版本：v0.0.1（持续开发中，可能经常面临内容变化，谨慎使用）

## 简介

MCCP-toolchain 是一个用于进行MCCP工程构建的工具链，主要由python脚本和预存的系统提示词构成。

MCCP-toolchain 其自身也是一个符合MCCP规范的工程。（目前还不是，需要先完成第一次自举）。具体协议约定和规范请参考另一个仓库：[model-context-code-protocol](https://github.com/haberzero/model-context-code-protocol)

主要的脚本代码被存放在 src_main 文件夹中。

行为描述层和符号-伪代码层的源码则分别位于src_mcbc和src_mcpc文件夹中，对于一个MCCP工程而言，此二者的命名、位置可以改变（旁路式MCCP工程目录结构），但建议保持默认约定状态。

反向构建功能实现后，将会提供“旁路式”的工程文件夹构建方式，允许用户在完全不影响原有工程结构的状态下，在另一个完全独立的文件夹中（甚至处于别的服务器）管理所有MCCP抽象层级，便于企业用户在不影响原有工程结构的前提下，进行MCCP工程改造。

灵活且独立的旁路式文件夹结构也有利于团队协作 或工程位置迁移、版本回退等操作（也允许对MCCP工程内容进行剥离并弃用，不影响目标源代码）。

## 安装

1. 克隆仓库到本地
2. 安装依赖
3. 配置环境变量
4. 直接运行main.py脚本

## 运行

### 正向构建过程

1. 在弹出的窗口中，选中正向构建
2. 选取工程所在文件夹位置
3. 命名工程，建议使用纯英文和下划线的组合
4. 依据界面提供的指示，逐步进行脚本运行，过程中自行微调生成出的各抽象层级的代码
5. 每次手动修改层级内容后，需要运行update脚本功能，将修改内容在抽象层级间同步

### 反向构建过程

定义中，请等候

## 未来（画饼.mp4）

1. 同步且自动化的正/反向构建：初期目标仅为实现手动控制的正/反向构建，且二者流程应该基本上是互相分离的，未来此二者应该是作为同一套工作流程的两个功能面，具备互相配合的能力，达成层级间的完全同步。当一个工程能够多轮次、交替地复现正向/反向构建的所有流程时，便可认为其结构基本稳定。
2. 工具链自举：MCCP定义了一整套完善的ai编程流程，MCCP-toolchain就是这套ai编程流程的自动化工具。因此，MCCP-toolchain本身也应该根据MCCP的标准进行自我构建。
3. A / B 式轮替更新：工具具备自举能力不意味着它应该在开发过程中轻易地改变自己。因此，未来的项目开发应该遵循：用稳定的A工具链开发B版本工具链工程、B工具链稳定并固化，A版本工作流逐步迁移至B版本工具链，B版本工具链依据自身源码的拷贝进行新轮次迭代。B版本的小bug热修复可以基于自身进行，但大的问题修复总应该针对新的拷贝进行操作，直到新的稳定版本被固化。
4. 单工程多语言支持：初期demo仅尝试实现了对python的支持，便于尽快进行第一次自举。未来应该支持在单一工程中构建不同的目标编程语言，并提供良好的胶水层构建实现。
5. 开放兼容性接口：MCCP-toolchain应该永远保持开放，允许第三方能够轻易地根据自己的LLM模型的特征来定义系统提示词、定义模型信息的流转方式，只要最终生成的代码内容符合MCCP规范即可。
6. 商业版：MCCP-toolchain计划在未来细分为社区版和商业版（是的，有商业计划，虽然很遥远）。商业版将更注重于易部署、高稳定性、团队协作、大项目的层级分离、多分支间同步 等问题，其基本功能、思想内核与社区版不会出现任何区别。社区版和商业版应该总是保持同步更新迭代。一个具备收入能力和良好市场反馈的项目才能更长久地运转下去。
7. 与第三方工具的配合：以SCnos为例。此构建工具基于python，和其它诸如G++等编译链达成配合，进行比如C++工程的构建。我当前对SCons的理解其实很浅薄，但直觉来说它可能可以给我带来很强的助力。因此，MCCP-toolchain未来应该考虑与第三方工具的良好配合，提供插件接口、或者将MCCP-toolchain自身插件化都是待选方案。（当然这也过于遥远）
